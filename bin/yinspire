#!/usr/bin/env ruby

# TODO: Dump at the end.

begin
  require 'rubygems'
rescue LoadError
end

begin
  require 'Yinspire'
rescue LoadError
  $LOAD_PATH.unshift(File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib')))
  require 'Yinspire'
end
require 'Yinspire/All'

LOADERS = {
  :yin => Loader_Yin,
  :json => Loader_JSON,
  :graphml => Loader_GraphML,
  :spike => Loader_Spike
}

DUMPERS = {
  :dot => Dumper_Dot
}

def parse_cmdline
  require 'optparse'
  require 'ostruct'

  options = OpenStruct.new 
  options.current_format = :yin
  options.stop_at = Infinity
  options.tolerance = 0.0
  options.output = nil
  options.record_id = Hash.new 
  options.record_type = Hash.new 
  options.do_not_simulate = false
  options.force_compilation = false
  options.tmp = "/tmp/Yinspire"

  options.dumps = []
  options.inputs = []

  opts = OptionParser.new do |opts|
    opts.banner = "Usage: yinspire [options] [file] [options] [file] ..."

    opts.on("-s", "--stop-at N", Float, "Stop simulation at N (default: #{options.stop_at})") do |n|
      options.stop_at = n
    end

    opts.on("--tolerance N", Float, "Stimuli tolerance (default: #{options.tolerance})") do |n|
      options.tolerance = n
    end

    opts.on("-f", "--format FORMAT", LOADERS.keys,
            "Select format type of input files",
            "  (#{LOADERS.keys.join(', ')})") do |t|
      options.current_format = t
    end

    opts.on("-i", "--input FILE", "Input file") do |inp|
      options.inputs << [options.current_format, inp]
    end

    opts.on("-o", "--output FILE", "Filename to write output to",
                                   "  (default: stdout)") do |out|
      raise "only one output allowed" if options.output
      options.output = out
    end

    opts.on("--record-id x,y,z", Array, "NeuralEntity ids for which to record fire events.",
                                   "  (default: ALL)") do |ids|
      ids.each {|i| options.record_id[i] = true} 
    end

    opts.on("--record-type x,y,z", Array, "NeuralEntity types for which to record fire events.",
                                   "  (default: ALL)") do |types|
      types.each {|i| options.record_type[i] = true} 
    end

    opts.on("-d", "--dump FILE:FORMAT", "Dump net to file (after simulation)",
                                        "  (formats: #{DUMPERS.keys.join(', ')})") do |t|
      file, format = t.split(":")
      raise "invalid FORMAT" if format.nil? or !DUMPERS.include?(format.to_sym)
      options.dumps << [file, format.to_sym]
    end

    opts.on("--do-not-simulate", "Do not simulate") do
      options.do_not_simulate = true
    end

    opts.on("--force-compilation", "Force (re-)compilation of Yinspire") do
      options.force_compilation = true
    end

    opts.on("--tmp DIR", "Temporary directory for compilation",
                         "  (default: #{options.tmp})") do |tmp|
      options.tmp = tmp
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  unparsed = opts.order(ARGV.dup) {|arg|
    options.inputs << [options.current_format, arg]
  }
  if !unparsed.empty? or options.inputs.empty? 
    puts opts
    exit
  end

  return options
end

class Simulator
  EXT = "!!!EXTERNAL!!!".freeze
  def record_fire(at, weight, source)
    id = source ? source.id : EXT 

    return if $yinspire_record_ids && !$yinspire_record_ids[id]
    return if $yinspire_record_types && !$yinspire_record_types[source.class]

    $yinspire_out << "#{id}\t#{weight}@#{at}\n"
  end
end

def run
  options = parse_cmdline()

  Yinspire.commit(File.join(options.tmp, "Yinspire"), options.force_compilation)

  $yinspire_out = STDOUT
  if options.output and options.output != "-"
    $yinspire_out = File.open(options.output, "w+")
  end

  if options.record_id.empty?
    # nil == ALL
    $yinspire_record_ids = nil
  else
    $yinspire_record_ids = options.record_id
  end

  if options.record_type.empty?
    # nil == ALL
    $yinspire_record_types = nil
  else
    begin
      $yinspire_record_types = Hash.new
      options.record_type.each {|t, _| $yinspire_record_types[NeuralEntity.class_from_name(t)] = true }
    rescue ArgumentError
      STDERR.puts "Invalid/unknown type specified in --record-type"
      STDERR.puts "Use one of: #{ NeuralEntity.entity_type_map.keys.join(', ') }"
      exit 1
    end
  end

  sim = Simulator.new
  sim.stimuli_tolerance = options.tolerance

  options.inputs.each do |format, file|
    LOADERS[format].new(sim).load(file)
  end

  sim.run(options.stop_at) unless options.do_not_simulate

  $yinspire_out.close if options.output and options.output != "-"

  # dump nets
  options.dumps.each do |file, format|
    dumper = DUMPERS[format].new(sim)
    if file == "-"
      dumper.dump(STDOUT)
    else
      File.open(file, 'w+') {|f| dumper.dump(f) }
    end
  end
end

run()
